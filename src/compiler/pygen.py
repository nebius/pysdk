import io
from keyword import iskeyword, issoftkeyword
from types import TracebackType
from typing import Any, Literal, TextIO

GENERATED_NOTE = """
Generated by the nebius pygen.  DO NOT EDIT!
"""


class GenerationError(Exception):
    pass


class ImportPath:
    def __init__(self, import_path: str, suggest_name: str | None = None) -> None:
        self.import_path = import_path
        self.suggest_name = suggest_name


class ImportedSymbol:
    def __init__(self, name: str, import_path: ImportPath | str) -> None:
        self.name = name
        self.import_path = (
            import_path
            if isinstance(import_path, ImportPath)
            else ImportPath(import_path)
        )


class PyGenFile:
    def __init__(
        self,
        name: str,
        path: str,
        import_path: str | ImportPath,
        indent_sequence: str | None,
        shebang_command: str | None,
        generated_note: str | None,
    ) -> None:
        self._name = name
        self._shebang_command = shebang_command
        self._generated_note = (
            generated_note if generated_note is not None else GENERATED_NOTE
        )
        self._path = path
        self._import_path = (
            import_path if isinstance(import_path, str) else import_path.import_path
        )
        self._main_code = ""
        self._imports = dict[str, ImportPath]()
        self._imports_reversed = dict[str, str]()
        self._indent_sequence = (
            indent_sequence if indent_sequence is not None else "    "
        )
        self._indent = 0
        self._finalized = False

    def add_import(
        self,
        import_path: ImportPath | str,
        suggest_name: str | None = None,
    ) -> ImportPath:
        if self._finalized:
            GenerationError("can't add imports to finalized file")
        import_path_str = (
            import_path.import_path
            if isinstance(import_path, ImportPath)
            else import_path
        )
        if import_path_str == self._import_path:
            return ImportPath(import_path_str)
        if import_path_str in self._imports:
            return self._imports[import_path_str]
        if suggest_name is None and isinstance(import_path, ImportPath):
            suggest_name = import_path.suggest_name
        if suggest_name is None:
            suggest_name = import_path_str.split(".")[-1]
        if not isinstance(import_path, ImportPath):
            import_path = ImportPath(import_path, suggest_name)

        def is_reserved(s: str) -> bool:
            return s in self._imports_reversed or iskeyword(s) or issoftkeyword(s)

        if is_reserved(suggest_name):
            inc = 1
            while True:
                new_suggest_name = f"{suggest_name}_{inc}"
                if not is_reserved(new_suggest_name):
                    break
                inc += 1
            suggest_name = new_suggest_name
        else:
            suggest_name = suggest_name

        import_path = ImportPath(import_path.import_path, suggest_name)
        self._imports[import_path.import_path] = import_path
        self._imports_reversed[suggest_name] = import_path.import_path
        return import_path

    def indent(self) -> None:
        if self._finalized:
            GenerationError("can't indent finalized file")
        self._indent += 1

    def unindent(self) -> None:
        if self._indent <= 0:
            raise GenerationError("can't unindent more")
        self._indent -= 1

    def __enter__(self) -> "PyGenFile":
        self.indent()
        return self

    def __exit__(
        self,
        type_: type[BaseException] | None,
        value: BaseException | None,
        traceback: TracebackType | None,
    ) -> Literal[False]:
        self.unindent()
        return False

    def g(
        self,
        *args: str | ImportedSymbol | ImportPath | Any,
        noident: bool = False,
    ) -> None:
        if self._finalized:
            GenerationError("can't add lines to finalized file")
        line: str = ""
        for arg in args:
            if isinstance(arg, ImportedSymbol):
                if arg.import_path.import_path == self._import_path:
                    line += arg.name
                else:
                    import_path = self.add_import(arg.import_path)
                    line += str(import_path.suggest_name) + "." + arg.name
            elif isinstance(arg, ImportPath):
                if arg.import_path == self._import_path:
                    raise GenerationError(
                        f"can't add import path {arg.import_path} as an import to"
                        " itself"
                    )
                import_path = self.add_import(arg.import_path)
                line += str(import_path.suggest_name)
            else:
                line += f"{arg}"
        if not noident:
            self._main_code += "".join([self._indent_sequence] * self._indent)
        self._main_code += line + "\n"

    def dump(self, writer: TextIO) -> None:
        self._finalized = True
        if self._shebang_command is not None:
            writer.write("#!")
            writer.write(self._shebang_command)
            writer.write("\n")
        gen_note = self._generated_note.split("\n")
        for line in gen_note:
            writer.write("#")
            writer.write(line)
            writer.write("\n")
        writer.write("\n")
        for _imp in self._imports.values():
            writer.write("import ")
            writer.write(_imp.import_path)
            writer.write(" as ")
            writer.write(str(_imp.suggest_name))
            writer.write("\n")
        writer.write("\n")
        writer.write(self._main_code)
        writer.flush()

    def dumps(self) -> str:
        ret = io.StringIO("")
        self.dump(ret)
        return ret.getvalue()
